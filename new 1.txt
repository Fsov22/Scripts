Ability.CastPosition(blink, (Entity.GetAbsOrigin(enemy) + (Entity.GetAbsOrigin(myHero) - Entity.GetAbsOrigin(enemy)):Normalized():Scaled(75)))

function FAIO.PudgeHookCollisionChecker(myHero, target)

	if not myHero then return false end
	if not target then return false end

	local pred = 0.3 + NPC.GetTimeToFace(myHero, target) + (Entity.GetAbsOrigin(target):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
	local predPos = FAIO.castPrediction(myHero, target, pred)

	local searchRadius = 125
	local distance = (Entity.GetAbsOrigin(myHero) - predPos):Length2D()

	for i = 1, math.floor(distance / searchRadius) do
		local checkVec = (predPos - Entity.GetAbsOrigin(myHero)):Normalized()
		local checkPos = Entity.GetAbsOrigin(myHero) + checkVec:Scaled(i * searchRadius)
		local unitsAround = Wrap.NInRadius(checkPos, searchRadius, Entity.GetTeamNum(myHero), Enum.TeamType.TEAM_BOTH)
		local check = false
			for _, unit in ipairs(unitsAround) do
				if unit and Wrap.EIsNPC(unit) and unit ~= target and unit ~= myHero and Wrap.EIsAlive(unit) and not Entity.IsDormant(unit) and not NPC.IsStructure(unit) and not NPC.IsBarracks(unit) and not NPC.IsWaitingToSpawn(unit) and NPC.GetUnitName(unit) ~= "npc_dota_neutral_caster" and NPC.GetUnitName(unit) ~= nil then
					check = true
					break
				end
			end

		if check then
			return false
		end	

	end

	return true

end

WrapUtility.NInRadius = function (vec, radius, teamNum, teamType)
	local  tbl = NPCs.InRadius(vec, radius, teamNum, teamType)
	if tbl ~= nil then
		return tbl
	else
		return {}
	end
end

WrapUtility.EIsNPC = function (entity)
	if entity and entity ~= 0 then
		return Entity.IsNPC(entity)
	else
		return false
	end
end

WrapUtility.EIsAlive = function (entity)
	if entity and entity ~= 0 then
		return Entity.IsAlive(entity)
	else
		return false
	end
end

function FAIO.castPrediction(myHero, enemy, adjustmentVariable)

	if not myHero then return end
	if not enemy then return end

	local enemyRotation = Entity.GetRotation(enemy):GetVectors()
		enemyRotation:SetZ(0)
    	local enemyOrigin = Entity.GetAbsOrigin(enemy)
		enemyOrigin:SetZ(0)

	if enemyRotation and enemyOrigin then
			if not NPC.IsRunning(enemy) then
				return enemyOrigin
			else return enemyOrigin:__add(enemyRotation:Normalized():Scaled(FAIO.GetMoveSpeed(enemy) * adjustmentVariable))
			end
	end
end

if Menu.IsEnabled(FAIO.optionHeroPudgeHookCombo) and not check and not NPC.HasModifier(myHero, "modifier_item_forcestaff_active") then
						if Q and Ability.IsCastable(Q, myMana) and NPC.IsEntityInRange(myHero, enemy, Menu.GetValue(FAIO.optionHeroPudgeHookComboMaxRange)) and not NPC.IsChannellingAbility(myHero) then
							if FAIO.PudgeHookCollisionChecker(myHero, enemy) and not FAIO.PudgeHookJukingChecker(myHero, enemy) then
								local hookPrediction = Ability.GetCastPoint(Q) + NPC.GetTimeToFace(myHero, enemy) + (Entity.GetAbsOrigin(enemy):__sub(Entity.GetAbsOrigin(myHero)):Length2D() / 1450) + (NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) * 2)
								local hookPredictedPos = FAIO.castPrediction(myHero, enemy, hookPrediction)
								Ability.CastPosition(Q, Entity.GetAbsOrigin(myHero) + (hookPredictedPos - Entity.GetAbsOrigin(myHero)):Normalized():Scaled(500))
								FAIO.PudgeHookStartTimer = os.clock() + NetChannel.GetAvgLatency(Enum.Flow.FLOW_OUTGOING) + FAIO.TimeToFacePosition(myHero, hookPredictedPos)
								FAIO.PudgeHookTargetedPos = hookPredictedPos
								FAIO.lastTick = os.clock() + 0.3
								return
							end
						end
					end
				end
			end